{
	parserClass="org.intellij.plugins.ceylon.parser.CeylonParser"
	stubParserClass="org.intellij.plugins.ceylon.parser.CeylonParserUtil"

	implements="org.intellij.plugins.ceylon.psi.CeylonCompositeElement"
	extends="org.intellij.plugins.ceylon.psi.impl.CeylonCompositeElementImpl"

	psiClassPrefix="Ceylon"
	psiImplClassSuffix="Impl"

	psiPackage="org.intellij.plugins.ceylon.psi"
	psiImplPackage="org.intellij.plugins.ceylon.psi.impl"

	psiImplUtilClass="org.intellij.plugins.ceylon.psi.CeylonPsiUtils"

	elementTypeHolderClass="org.intellij.plugins.ceylon.psi.CeylonTypes"
	elementTypeClass="org.intellij.plugins.ceylon.psi.CeylonElementType"
	tokenTypeClass="org.intellij.plugins.ceylon.psi.CeylonTokenType"

	tokens = [
	    OP_COMMA=","
	    OP_SEMI_COLUMN=";"
	    OP_ELLIPSIS="..."
        OP_SHARP="#"
	    OP_LBRACE="{"
	    OP_RBRACE="}"
	    OP_LPAREN="("
	    OP_RPAREN=")"
	    OP_LBRACKET="["
	    OP_RBRACKET="]"
	    OP_BRACKETS="[]"
	    OP_DOT="."
	    OP_DOT_QUESTION="?."
	    OP_BRACKETS_DOT="[]."
	    OP_EQUALS="="
	    OP_PLUS="+"
	    OP_MINUS="-"
	    OP_DIVIDE="/"
	    OP_MULTIPLY="*"
	    OP_MODULO="%"
	    OP_MULT_MULT="**"
	    OP_PLUS_PLUS="++"
	    OP_MIN_MIN="--"
	    OP_DOT_DOT=".."
	    OP_ARROW="->"
	    OP_QUESTION="?"
	    OP_NOT="!"
	    OP_LOGICAL_AND="&&"
	    OP_LOGICAL_OR="||"
	    OP_TIDLE="~"
	    OP_INTERSECTION="&"
	    OP_UNION="|"
	    OP_XOR="^"
	    OP_EQ_EQ_EQ="==="
	    OP_EQ_EQ="=="
	    OP_EXCL_EQ="!="
	    OP_LT="<"
	    OP_GT=">"
	    OP_LTE="<="
	    OP_GTE=">="
	    OP_DIFFERENT="<=>"
	    OP_ASSIGN=":="
	    OP_DOT_EQ=".="
	    OP_PLUS_EQ="+="
	    OP_MINUS_EQ="-="
	    OP_DIV_EQ="/="
	    OP_MULT_EQ="*="
	    OP_MOD_EQ="%="
	    OP_OR_EQ="|="
	    OP_AND_EQ="&="
	    OP_XOR_EQ="^="
	    OP_NOT_EQ="~="
	    OP_LOG_OR_EQ="||="
	    OP_LOG_AND_EQ="&&="
	    OP_ANNOTATION="@"

        KW_IMPORT="import"
        KW_CLASS="class"
        KW_INTERFACE="interface"
        KW_OBJECT="object"
        KW_GIVEN="given"
        KW_VALUE="value"
        KW_ASSIGN="assign"
        KW_VOID="void"
        KW_FUNCTION="function"
        KW_OF="of"
        KW_EXTENDS="extends"
        KW_SATISFIES="satisfies"
        KW_ADAPTS="adapts"
        KW_ABSTRACTS="abstracts"
        KW_IN="in"
        KW_OUT="out"
        KW_RETURN="return"
        KW_BREAK="break"
        KW_CONTINUE="continue"
        KW_THROW="throw"
        KW_IF="if"
        KW_ELSE="else"
        KW_SWITCH="switch"
        KW_CASE="case"
        KW_FOR="for"
        KW_WHILE="while"
        KW_TRY="try"
        KW_CATCH="catch"
        KW_FINALLY="finally"
        KW_THEN="then"
        KW_THIS="this"
        KW_OUTER="outer"
        KW_SUPER="super"
        KW_IS="is"
        KW_EXISTS="exists"
        KW_NONEMPTY="nonempty"
        KW_MODULE="module"

//        KW_SHARED="shared"
//        KW_ABSTRACT="abstract"
//        KW_FORMAL="formal"
//        KW_DEFAULT="default"
//        KW_ACTUAL="actual"
//        KW_VARIABLE="variable"
//        KW_DEPRECATED="deprecated"
//        KW_LITERAL="literal"
//        KW_SMALL="small"
	]
}

external ceylon ::= parseCeylon compilationUnit
private Comment ::= LINE_COMMENT | MULTI_LINE_COMMENT

compilationUnit ::= (compilerAnnotations ";")?
      (
        Comment
        | compilerAnnotations annotations (moduleDescriptor | packageDescriptor)
        | importList? (compilerAnnotations declaration)+ // TODO was * instead of +
      )
    {recoverUntil=ceylon_statement_recover}

private ceylon_statement_recover ::= (!compilationUnit)

moduleDescriptor ::= "module" packagePath QUOTED_LITERAL importModuleList

importModuleList ::= "{" (compilerAnnotations annotations importModule)* "}"

packageDescriptor ::= "package" packagePath ";"

importModule ::= "import" (QUOTED_LITERAL | packagePath) QUOTED_LITERAL ";"

importList  ::=  importDeclaration+

importDeclaration ::= "import" (packagePath) importElementList

importElementList ::= "{" (importElement ( "," (importElement | importWildcard))* | importWildcard )? "}"

importElement ::= compilerAnnotations importName ("=" importName)? importElementList?

importWildcard ::= "..."

importName ::= memberName | typeName

packagePath ::= packageName ("." packageName)*

packageName ::= LIDENTIFIER | UIDENTIFIER

typeName ::= UIDENTIFIER

annotationName ::= ("shared" | LIDENTIFIER)

memberName ::= LIDENTIFIER

memberNameDeclaration ::= memberName | typeName

typeNameDeclaration ::= typeName | memberName

objectDeclaration ::= "object" memberNameDeclaration extendedType? satisfiedTypes? (classBody | ";")

voidOrInferredMethodDeclaration ::= ("void" | "function") memberNameDeclaration typeParameters? parameters* /*metatypes? */ typeConstraints? (block | specifier? ";")

setterDeclaration ::= "assign" memberNameDeclaration (block | ";")

inferredAttributeDeclaration ::= "value" memberNameDeclaration ((specifier | initializer)? ";" | block)

typedMethodOrAttributeDeclaration ::= type memberNameDeclaration
    (
        typeParameters? parameters+ /*metatypes?*/ typeConstraints? (block | specifier? ";")
      | (specifier | initializer)? ";"
      | block
    )

interfaceDeclaration ::= "interface" typeNameDeclaration
        typeParameters? caseTypes? /*metatypes?*/ adaptedTypes? satisfiedTypes?
        typeConstraints? (interfaceBody | typeSpecifier? ";")

classDeclaration  ::= "class" typeNameDeclaration
        typeParameters? parameters? caseTypes? /*metatypes?*/ extendedType? satisfiedTypes?
        typeConstraints? (classBody | typeSpecifier? ";") {
    pin=1
    stub="org.intellij.plugins.ceylon.psi.stub.ClassStub"
    elementTypeClass="org.intellij.plugins.ceylon.psi.stub.impl.ClassElementType"
}

aliasDeclaration ::= "alias" typeNameDeclaration typeParameters? typeConstraints? typeSpecifier? ";"

assertion ::= ASSERT conditions ";"

block ::="{" declarationOrStatement* "}"

//Note: interface bodies can't really contain 
//      statements, but error recovery works
//      much better if we validate that later
//      on, instead of doing it in the parser.
interfaceBody ::= "{" declarationOrStatement* "}"

classBody ::= "{" declarationOrStatement* "}"

extendedType ::= "extends" (qualifiedType | "super" "." typeReference) positionalArguments // TODO "positionalArguments?"

satisfiedTypes ::= "satisfies" qualifiedType ("&" qualifiedType)*

abstractedType ::= "abstracts" qualifiedType

adaptedTypes ::= "adapts" qualifiedType ("&" qualifiedType)*

caseTypes ::= "of" caseType ("|" caseType)*

caseType ::= qualifiedType | memberName

//Support for metatypes
//Note that we don't need this for now
/*metatypes
   ::="is" type ('&' type)* 
    -> ^(METATYPES[$"is"] type*)
    ;*/

parameters ::= "(" (parameterDeclaration ("," parameterDeclaration)*)? ")"

//special rule for syntactic predicate
//to distinguish between a formal 
//parameter list and a parenthesized body 
//of an inline callable argument
//be careful with this one, since it 
//matches "()", which can also be an 
//argument list
//parametersStart
//   ::="(" ( annotatedDeclarationStart | ")" )
//    ;

// FIXME: This accepts more than the language spec: named arguments
// and varargs arguments can appear in any order.  We'll have to
// enforce the rule that the ... appears at the end of the parapmeter
// list in a later pass of the compiler.
parameter 

   ::= parameterType

      memberName

      (
        (
          parameters

        )+
        |
        (
          valueParameter
        )?
        //-> ^(VALUE_PARAMETER_DECLARATION parameterType memberName specifier?)

          //for callable parameters
        //-> ^(FUNCTIONAL_PARAMETER_DECLARATION parameterType memberName parameters+ specifier?)
      )
      (
        specifier

      )?

parameterRef 

   ::=memberName

      (
        specifier

      )?

parameterDeclaration 
   ::=compilerAnnotations
      (
//        (LIDENTIFIER ("="|","|")")) =>
        parameterRef

      | 
        annotations 
        parameter

      )

valueParameter
   ::="->" type memberName

parameterType 
   ::=type 

      ( 
        "..."

      )?
    | "void"

typeParameters 
   ::="<"

      typeParameter

      (
        ","

        (
          typeParameter

        | 
        )
      )*
      ">"

    //-> ^(TYPE_PARAMETER_LIST[$"<"] typeParameter+)

typeParameter 
   ::=
      ( 
        variance 

      )? 
      typeNameDeclaration

      (
        "..."

      )?
    //-> ^(TYPE_PARAMETER_DECLARATION variance? typeName)

variance 
   ::="in" //-> ^(TYPE_VARIANCE[$"in"])

    | "out" //-> ^(TYPE_VARIANCE[$"out"])

typeConstraint 
   ::=compilerAnnotations
      "given"

      typeNameDeclaration 

      //(typeParameters)?
      (
        parameters

      )?
      (
        caseTypes

      )?
      //metatypes? 
      (
        satisfiedTypes

      )?
      ( 
        abstractedType

      )?

typeConstraints 
   ::=
      (
        typeConstraint

      )+
    //-> ^("given"_LIST typeConstraint2+)

declarationOrStatement ::=compilerAnnotations
      ( 
        annotation* (assertion | declaration)
      | statement
      | Comment
      )

declaration 
   ::= annotations
    ( 
      objectDeclaration

    | setterDeclaration

    | voidOrInferredMethodDeclaration

    | inferredAttributeDeclaration

    | typedMethodOrAttributeDeclaration

    | classDeclaration

    | interfaceDeclaration

    | aliasDeclaration

    )

//special rule for syntactic predicate
//to distinguish between an annotation
//and an expression statement
/*annotatedDeclarationStart
   ::=declarationStart
    | LIDENTIFIER
      ( 
          declarationStart
        | LIDENTIFIER
        | nonstringLiteral | stringLiteral
        | arguments annotatedDeclarationStart //we need to recurse because it could be an inline callable argument
      )
    ;*/

//annotatedDeclarationStart
//   ::=declarationStart
//    ;

//special rule for syntactic predicates
//that distinguish declarations from
//expressions
//declarationStart
//   ::=declarationKeyword
//    | type ("..." | LIDENTIFIER)
//    ;

//declarationKeyword
//   ::="value"
//    | "function"
//    | "assign"
//    | "void"
//    | "interface"
//    | "class"
//    | "object"
//    | "alias"
//    ;

statement 
   ::=directiveStatement

    | controlStatement

    | expressionOrSpecificationStatement

expressionOrSpecificationStatement 

   ::=expression 

      (
        specifier

      )?

      (
        ";"

      | 
        ","

      )

directiveStatement 
   ::=directive 

      ";"

directive 
   ::=returnDirective

    | throwDirective

    | breakDirective

    | continueDirective

returnDirective 
   ::="return" 

      (
        functionOrExpression

      )?

throwDirective 
   ::="throw"

      ( 
        expression

      )?

breakDirective 
   ::="break"

continueDirective 
   ::="continue"

typeSpecifier 
   ::="=" 

      type

    //-> ^(TYPE_SPECIFIER[$"="] type)

specifier 
   ::="=" 

      functionOrExpression

initializer 
   ::=":="

      expression

    //-> ^(INITIALIZER_EXPRESSION[$"assign"_OP] expression)

expression 
   ::=
      assignmentExpression

base 
   ::=nonstringLiteral

    | stringExpression

    | enumeration

    | selfReference

    | parExpression

    | baseReference

baseReference 
   ::=
    (
      supertypeQualifier

    )?
    (
      memberReference

    | typeReference

    )

supertypeQualifier 
   ::=typeName "::"

primary 
   ::=base

    (   
      //TODO: re-enable:
        /*inlineFunctionalArgument
      |*/ qualifiedReference

      | arguments

      | indexOrIndexRange 

    )*

qualifiedReference 
   ::=memberSelectionOperator 

      ( 
        memberReference

      | typeReference

      )

memberSelectionOperator 
   ::="."

    | "?."

    | "[]."

elementSelectionOperator 
   ::="?["

    | "["

enumeration 
   ::="{"  
      (
        sequencedArgument

      | 
        comprehension

      )?
      "}"

expressions 
   ::=
      expression 

      ( "," 

        (
          expression 

        |  //TODO: sometimes it should be ")"!
        )
      )*

memberReference 
   ::=memberName

      (
         typeArguments

      )?

typeReference 
   ::=typeName 

      (
        typeArguments

      )?

//special rule for syntactic predicate to 
//determine if we have a < operator, or a
//type argument list
//typeArgumentsStart
//   ::="<"
//    (
//      UIDENTIFIER ('.' UIDENTIFIER)* /*| 'subtype')*/ ("default"|"[]")*
//      (("&"|"|"|"->") UIDENTIFIER ('.' UIDENTIFIER)* ("default"|"[]")*)*
//      (">"|"<"|","|"..."|"("|")")
//    |
//      ">" //for IDE only!
//    )
//    ;

indexOrIndexRange 
    //TODO: move indexOperator to ElementOrRange and
    //      make this rule return ElementOrRange instead
    //      of IndexExpression, instantiating IndexExpression
    //      from the calling primary rule
   ::=elementSelectionOperator

      index

      (
        "..."

      | ".." 

        index 

      | ":"

        index 

      )?
      "]"

index 
   ::=additiveExpression 

arguments ::= positionalArguments | namedArguments

namedArguments 
   ::="{" 

      ( //TODO: get rid of the predicate and use the approach
        //      in expressionOrSpecificationStatement
//        (namedArgumentStart)
        namedArgument

      )* 
      ( 
        sequencedArgument

      | 
        comprehension

      )?
      "}"

sequencedArgument 
   ::=compilerAnnotations
      expressions

      (
        "..."

      )?

namedArgument 
   ::=compilerAnnotations 
    ( 
      namedSpecifiedArgument

    | 
      namedArgumentDeclaration

    )

namedSpecifiedArgument 
   ::=memberNameDeclaration 

      specifier 

      ";"

objectArgument 
   ::="object" 

      memberNameDeclaration

      ( 
        extendedType

      )?
      ( 
        satisfiedTypes

      )?
      (
        classBody

      | 
        ";"

      )
    //-> ^(OBJECT_ARGUMENT[$"object"] "value" memberName extendedType? satisfiedTypes? classBody?)

voidOrInferredMethodArgument 
   ::=
      (
        "void"

      |
        "function"

      ) 
      memberNameDeclaration 

      (
        parameters

      )*
      block

    //-> ^(METHOD_ARGUMENT "void" memberName parameters* block)

inferredGetterArgument 
   ::=
      "value" 

      memberNameDeclaration 

      block

      //-> ^(ATTRIBUTE_ARGUMENT "value" memberName block)      

typedMethodOrGetterArgument 

   ::=type 

      memberNameDeclaration

      ( 

        (
          parameters

        )+
      )?
      block

      //-> ^(METHOD_ARGUMENT unionType memberName parameters+ memberBody)
      //-> ^(ATTRIBUTE_ARGUMENT unionType memberName memberBody)      

namedArgumentDeclaration 
   ::=objectArgument

    | typedMethodOrGetterArgument

    | voidOrInferredMethodArgument

    | inferredGetterArgument

//special rule for syntactic predicate
//to distinguish between a named argument
//and a sequenced argument
//namedArgumentStart
//   ::=compilerAnnotation*
//      (specificationStart | declarationStart)
//    ;

//special rule for syntactic predicates
//specificationStart
//   ::=LIDENTIFIER '='
//    ;

parExpression  
   ::="(" 

      assignmentExpression

      ")"

positionalArguments 
   ::="(" 

      ( positionalArgument

        (
          "," 

          (
            positionalArgument

          | 
          )
        )* 
        (
          "..."

        )?
      )? 
      (
        comprehension

      )?
      ")"

positionalArgument 

   ::=functionOrExpression

functionOrExpression 

   ::=
      (
        "function" 

      | "void"

      )?
      parameters

      ( 
//        (parametersStart)=>
        parameters

      )*
      expression

    /*| "value"
      { fa.setType(new FunctionModifier($"value")); } 
      e1=expression
      { fa.addParameterList(new ParameterList(null));
        fa.setExpression($e1.expression); 
        $positionalArgument = fa; }*/
    | expression

/*inlineFunctionalArgument
   ::=memberName ((parametersStart) => parameters)? 
      ("(" expression ")" | block)
    ;*/

comprehension 

   ::=forComprehensionClause

comprehensionClause 
   ::=forComprehensionClause 

    | ifComprehensionClause 

    | expressionComprehensionClause 

expressionComprehensionClause 
   ::=expression

    | 

forComprehensionClause 
   ::="for"

      forIterator

      comprehensionClause

ifComprehensionClause 
   ::="if"

      conditions

      comprehensionClause

assignmentExpression 
   ::=thenElseExpression

      (
        assignmentOperator 

        assignmentExpression

      )?

assignmentOperator 
   ::=":="
    //| APPLY_OP 
    | "+="
    | "-="
    | "*="
    | "/="
    | "%="
    | "&="
    | "|="
    | "^="
    | "~="
    | "&&="
    | "||="
    //| DEFAULT_"assign"_OP { $operator = new DefaultAssignOp($DEFAULT_"assign"_OP); }

thenElseExpression 
   ::=disjunctionExpression

      (
        thenElseOperator 

        disjunctionExpression

      )*

thenElseOperator 
   ::="else" 

    | "then"

disjunctionExpression 
   ::=conjunctionExpression

      (
        disjunctionOperator 

        conjunctionExpression

      )*

disjunctionOperator 
   ::="||" 

conjunctionExpression 
   ::=logicalNegationExpression

      (
        conjunctionOperator 

        logicalNegationExpression

      )*

conjunctionOperator 
   ::="&&" 

logicalNegationExpression 
   ::=notOperator 

      logicalNegationExpression

    | equalityExpression

notOperator 
   ::="!" 

equalityExpression 
   ::=comparisonExpression

      (
        equalityOperator 

        comparisonExpression

      )?

equalityOperator 
   ::="==" 

    | "!="

    | "==="

comparisonExpression 
   ::=existenceEmptinessExpression

      (
        comparisonOperator 

        existenceEmptinessExpression

      | typeOperator

        type

      )?
    | typeOperator

      comparableType //TODO: support "type" here, using a predicate

      existenceEmptinessExpression

comparableType 
   ::=unionTypeExpression 

comparisonOperator 
   ::="<=>" 

    | "<="

    | ">="

    | ">"

    | "<"

    | "in"

typeOperator 
   ::="is"

    | "extends"

    | "satisfies"

existenceEmptinessExpression 
   ::=rangeIntervalEntryExpression

      (
        existsNonemptyOperator

      )?
    | existsNonemptyOperator

      rangeIntervalEntryExpression

existsNonemptyOperator 
   ::="exists" 

    | "nonempty"

rangeIntervalEntryExpression 
   ::=additiveExpression

      (
        rangeIntervalEntryOperator 

        additiveExpression

      )?

rangeIntervalEntryOperator 
   ::=".." 

    | ":"

    | "->"

additiveExpression 
   ::=multiplicativeExpression

      (
        additiveOperator 

        multiplicativeExpression

      )*

additiveOperator 
   ::="+" 

    | "-"

    | "|"

    | "^"

    | "~"

multiplicativeExpression 
   ::=defaultExpression

      (
        multiplicativeOperator 

        defaultExpression

      )*

multiplicativeOperator 
   ::="*" 

    | "/"

    | "%"

    | "&"

defaultExpression 
   ::=negationComplementExpression

      (
        defaultOperator 

        negationComplementExpression

      )*

defaultOperator 
   ::="default" 

negationComplementExpression 
   ::=unaryMinusOrComplementOperator 

      negationComplementExpression

    | exponentiationExpression

unaryMinusOrComplementOperator 
   ::="-" 

    | "+"

exponentiationExpression 
   ::=incrementDecrementExpression

      (
        exponentiationOperator

        exponentiationExpression

      )?

exponentiationOperator ::= "**"

incrementDecrementExpression 
   ::=prefixOperator

      incrementDecrementExpression

    | postfixIncrementDecrementExpression

prefixOperator ::= "--" | "++"

postfixIncrementDecrementExpression 
   ::=primary 

      (
        postfixOperator

      )*

postfixOperator 
   ::="--" 

    | "++" 

selfReference 
   ::="this"

    | "super" 

    | "outer"

nonstringLiteral ::= NATURAL_LITERAL | FLOAT_LITERAL | QUOTED_LITERAL | CHAR_LITERAL

stringExpression ::= stringTemplate | myStringLiteral

myStringLiteral ::= STRING_LITERAL

stringTemplate 
   ::=myStringLiteral

      (
        expression myStringLiteral

      )+

typeArguments 
   ::="<"

      typeArgument 

      (
        ","

        (
          typeArgument

          | 
        )
      )* 
      ">"

typeArgument 
   ::=type

      ( 
        "..."

      )? 

type 
   ::=unionType 

entryType 

   ::=abbreviatedType

      (
        "->"

        (
          abbreviatedType

//        | { displayRecognitionError(getTokenNames(), 
//                new MismatchedTokenException(UIDENTIFIER, input)); }
        )
      )?

unionType 

   ::=intersectionType

      ( 
        (
          "|"

          (
            intersectionType

//          | { displayRecognitionError(getTokenNames(), 
//                new MismatchedTokenException(UIDENTIFIER, input)); }
          )
        )+

      )?

intersectionType 

   ::=entryType

      ( 
        (
          "&"

          (
            entryType

//          | { displayRecognitionError(getTokenNames(), 
//                new MismatchedTokenException(UIDENTIFIER, input)); }
          )
        )+

      )?

abbreviatedType ::= qualifiedType ("?" | "[]" | "(" (type ("," type)* )? ")")*

unionTypeExpression ::= intersectionTypeExpression (("|" intersectionTypeExpression)+)?

intersectionTypeExpression ::=qualifiedType (("&" qualifiedType)+)?

qualifiedType ::= supertypeQualifier? typeNameWithArguments ("." typeNameWithArguments)*

typeNameWithArguments ::= typeName typeArguments?

annotations ::= annotation*

annotation ::= annotationName annotationArguments

annotationArguments ::= arguments | literalArguments

literalArguments ::= literalArgument*

literalArgument ::= nonstringLiteral | myStringLiteral

compilerAnnotations  ::= compilerAnnotation*

compilerAnnotation ::= "@" annotationName ("[" myStringLiteral "]")?

conditions ::="(" (condition ("," condition)*)? ")"

condition ::= existsCondition | nonemptyCondition | isCondition | satisfiesCondition | booleanCondition

booleanCondition ::= expression

existsCondition ::= "exists" (impliedVariable | specifiedVariable) | booleanCondition

nonemptyCondition ::= "nonempty" (impliedVariable | specifiedVariable) | booleanCondition

isCondition ::= ("!")? "is" type (impliedVariable | memberName specifier) | booleanCondition

satisfiesCondition ::= "satisfies" (qualifiedType qualifiedType)?

controlStatement ::= ifElse | switchCaseElse | whileLoop | forElse | tryCatchFinally

controlBlock ::= block

ifElse ::= ifBlock elseBlock?

ifBlock ::= "if" conditions controlBlock

elseBlock ::= "else" (elseIf | block)

elseIf ::= ifElse

switchCaseElse ::= switchHeader cases

switchHeader ::= "switch" "(" expression? ")"

cases ::= caseBlock+ defaultCaseBlock?

caseBlock ::= "case" "(" caseItem? ")" block

defaultCaseBlock ::= "else" block

caseItem ::= isCaseCondition | satisfiesCaseCondition | matchCaseCondition

matchCaseCondition ::= expressions

isCaseCondition ::= "is" type

satisfiesCaseCondition ::= "satisfies" qualifiedType

forElse ::= forBlock failBlock?

forBlock ::= "for" forIterator controlBlock

failBlock ::= "else" block

forIterator ::= "(" compilerAnnotations (var (containment | "->" var containment)?)? ")"

containment ::= "in" expression?

whileLoop ::= whileBlock

whileBlock ::= "while" conditions controlBlock

tryCatchFinally ::= tryBlock catchBlock* finallyBlock?

tryBlock ::= "try" (resource controlBlock | block)

catchBlock ::= "catch" catchVariable block

catchVariable ::= "(" variable? ")"

finallyBlock ::= "finally" block

resource ::= "(" (specifiedVariable | expression)? ")"

specifiedVariable ::= variable specifier?

variable ::= compilerAnnotations var

var ::= (type | "void" | "function" | "value") memberName parameters* | memberName | memberName parameters+

impliedVariable ::= memberName
